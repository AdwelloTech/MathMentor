import { InstantSession, IInstantSession } from '../models/InstantSession';
import mongoose from 'mongoose';

export interface CreateInstantSessionRequest {
  studentId: string;
  subjectId: string;
}

export interface AcceptInstantSessionRequest {
  requestId: string;
  tutorId: string;
}

export interface CancelInstantSessionRequest {
  requestId: string;
  userId: string;
  reason?: string;
}

class InstantSessionService {
  /**
   * Create a new instant session request
   */
  async createRequest(data: CreateInstantSessionRequest): Promise<IInstantSession> {
    const session = new InstantSession({
      studentId: new mongoose.Types.ObjectId(data.studentId),
      subjectId: new mongoose.Types.ObjectId(data.subjectId),
      durationMinutes: 15,
      status: 'pending',
      requestedAt: new Date()
    });

    await session.save();
    
    // Populate student and subject info
    await session.populate('studentId', 'fullName firstName lastName email');
    await session.populate('subjectId', 'name displayName color');
    
    return session;
  }

  /**
   * Get all pending requests (optionally filtered by subject)
   */
  async getPendingRequests(subjectId?: string, limit: number = 20): Promise<IInstantSession[]> {
    const query: any = { status: 'pending' };
    
    if (subjectId) {
      query.subjectId = new mongoose.Types.ObjectId(subjectId);
    }
    
    // Only show requests that are not stale (less than 5 minutes old)
    const fiveMinutesAgo = new Date(Date.now() - (5 * 60 * 1000));
    query.requestedAt = { $gte: fiveMinutesAgo };
    
    const sessions = await InstantSession.find(query)
      .populate('studentId', 'fullName firstName lastName email')
      .populate('subjectId', 'name displayName color')
      .sort({ requestedAt: 1 })
      .limit(limit);
    
    return sessions;
  }

  /**
   * Accept a pending instant session request
   */
  async acceptRequest(data: AcceptInstantSessionRequest): Promise<IInstantSession | null> {
    const session = await InstantSession.findById(data.requestId);
    
    if (!session) {
      throw new Error('Session request not found');
    }
    
    if (session.status !== 'pending') {
      throw new Error('Session request is no longer available');
    }
    
    // Check if request is stale (more than 5 minutes old)
    const fiveMinutesAgo = new Date(Date.now() - (5 * 60 * 1000));
    if (session.requestedAt < fiveMinutesAgo) {
      // Mark as expired
      session.status = 'expired';
      await session.save();
      throw new Error('Session request has expired');
    }
    
    // Accept the request - this will trigger the pre-save hook that generates jitsiMeetingUrl
    session.status = 'accepted';
    session.tutorId = new mongoose.Types.ObjectId(data.tutorId);
    // Don't set acceptedAt manually - let the pre-save hook do it
    
    await session.save();
    
    // Safety check: If the pre-save hook didn't generate the URL, do it manually
    if (!session.jitsiMeetingUrl) {
      console.warn('[InstantService] Meeting URL not generated by hook, generating manually');
      session.jitsiMeetingUrl = `https://meet.jit.si/MathMentor-instant_${session._id}`;
      await session.save();
    }
    
    // Populate tutor and subject info
    await session.populate('tutorId', 'fullName firstName lastName email');
    await session.populate('studentId', 'fullName firstName lastName email');
    await session.populate('subjectId', 'name displayName color');
    
    console.log('[InstantService] Session accepted with meeting URL:', session.jitsiMeetingUrl);
    
    return session;
  }

  /**
   * Cancel an instant session request
   */
  async cancelRequest(data: CancelInstantSessionRequest): Promise<IInstantSession | null> {
    const session = await InstantSession.findById(data.requestId);
    
    if (!session) {
      throw new Error('Session request not found');
    }
    
    if (session.status !== 'pending' && session.status !== 'accepted') {
      throw new Error('Only pending or accepted sessions can be cancelled');
    }
    
    session.status = 'cancelled';
    session.cancelledAt = new Date();
    session.cancelledBy = new mongoose.Types.ObjectId(data.userId);
    
    if (data.reason) {
      session.cancellationReason = data.reason;
    }
    
    await session.save();
    
    return session;
  }

  /**
   * Get session by ID
   */
  async getSessionById(sessionId: string): Promise<IInstantSession | null> {
    const session = await InstantSession.findById(sessionId)
      .populate('studentId', 'fullName firstName lastName email')
      .populate('tutorId', 'fullName firstName lastName email')
      .populate('subjectId', 'name displayName color');
    
    // Ensure meeting URL exists for accepted/in_progress sessions
    if (session && (session.status === 'accepted' || session.status === 'in_progress') && !session.jitsiMeetingUrl) {
      console.warn('[InstantService] Meeting URL missing in getSessionById, generating now');
      session.jitsiMeetingUrl = `https://meet.jit.si/MathMentor-instant_${session._id}`;
      await session.save();
    }
    
    return session;
  }

  /**
   * Get student's instant sessions
   */
  async getStudentSessions(studentId: string, limit: number = 10): Promise<IInstantSession[]> {
    const sessions = await InstantSession.find({
      studentId: new mongoose.Types.ObjectId(studentId)
    })
      .populate('tutorId', 'fullName firstName lastName email')
      .populate('subjectId', 'name displayName color')
      .sort({ createdAt: -1 })
      .limit(limit);
    
    return sessions;
  }

  /**
   * Get tutor's instant sessions
   */
  async getTutorSessions(tutorId: string, limit: number = 10): Promise<IInstantSession[]> {
    const sessions = await InstantSession.find({
      tutorId: new mongoose.Types.ObjectId(tutorId)
    })
      .populate('studentId', 'fullName firstName lastName email')
      .populate('subjectId', 'name displayName color')
      .sort({ createdAt: -1 })
      .limit(limit);
    
    return sessions;
  }

  /**
   * Mark tutor as joined
   */
  async markTutorJoined(sessionId: string): Promise<IInstantSession | null> {
    const session = await InstantSession.findById(sessionId);
    
    if (!session) {
      throw new Error('Session not found');
    }
    
    if (session.status !== 'accepted' && session.status !== 'in_progress') {
      throw new Error('Session must be accepted or in progress to mark tutor as joined');
    }
    
    // Ensure meeting URL exists
    if (!session.jitsiMeetingUrl) {
      console.warn('[InstantService] Meeting URL missing, generating now');
      session.jitsiMeetingUrl = `https://meet.jit.si/MathMentor-instant_${session._id}`;
    }
    
    session.tutorJoinedAt = new Date();
    await session.save();
    
    // Populate related data
    await session.populate('tutorId', 'fullName firstName lastName email');
    await session.populate('studentId', 'fullName firstName lastName email');
    await session.populate('subjectId', 'name displayName color');
    
    console.log('[InstantService] Tutor joined, meeting URL:', session.jitsiMeetingUrl);
    
    return session;
  }

  /**
   * Mark student as joined
   */
  async markStudentJoined(sessionId: string): Promise<IInstantSession | null> {
    const session = await InstantSession.findById(sessionId);
    
    if (!session) {
      throw new Error('Session not found');
    }
    
    if (session.status !== 'accepted' && session.status !== 'in_progress') {
      throw new Error('Session must be accepted or in progress to mark student as joined');
    }
    
    session.studentJoinedAt = new Date();
    await session.save();
    
    // Populate related data
    await session.populate('tutorId', 'fullName firstName lastName email');
    await session.populate('studentId', 'fullName firstName lastName email');
    await session.populate('subjectId', 'name displayName color');
    
    console.log('[InstantService] Student joined');
    
    return session;
  }

  /**
   * Start session (when both have joined)
   */
  async startSession(sessionId: string): Promise<IInstantSession | null> {
    const session = await InstantSession.findById(sessionId);
    
    if (!session) {
      throw new Error('Session not found');
    }
    
    if (session.status !== 'accepted') {
      throw new Error('Session must be accepted to start');
    }
    
    // Ensure meeting URL exists
    if (!session.jitsiMeetingUrl) {
      console.warn('[InstantService] Meeting URL missing in startSession, generating now');
      session.jitsiMeetingUrl = `https://meet.jit.si/MathMentor-instant_${session._id}`;
    }
    
    session.status = 'in_progress';
    session.startedAt = new Date();
    await session.save();
    
    // Populate related data
    await session.populate('tutorId', 'fullName firstName lastName email');
    await session.populate('studentId', 'fullName firstName lastName email');
    await session.populate('subjectId', 'name displayName color');
    
    console.log('[InstantService] Session started, meeting URL:', session.jitsiMeetingUrl);
    
    return session;
  }

  /**
   * Complete session
   */
  async completeSession(sessionId: string): Promise<IInstantSession | null> {
    const session = await InstantSession.findById(sessionId);
    
    if (!session) {
      throw new Error('Session not found');
    }
    
    if (session.status !== 'in_progress' && session.status !== 'accepted') {
      throw new Error('Session must be in progress or accepted to complete');
    }
    
    session.status = 'completed';
    session.completedAt = new Date();
    await session.save();
    
    return session;
  }

  /**
   * Cleanup stale and expired sessions
   */
  async cleanupSessions(): Promise<{ staleCount: number; expiredCount: number }> {
    // Clean up stale pending requests (older than 5 minutes)
    const staleCount = await (InstantSession as any).cleanupStaleRequests();
    
    // Expire accepted sessions that exceeded 15 minutes
    const expiredCount = await (InstantSession as any).expireOldSessions();
    
    return { staleCount, expiredCount };
  }
}

export default new InstantSessionService();

